

# 深入理解大数据之——事务ACID特性的实现原理
[TOC]

## 事务的ACID特性

事务（Transaction）是由一系列对系统中数据进行访问或更新的操作所组成的一个程序执行逻辑单元（Unit）。



在事务的ACID特性中，C即一致性是事务的根本追求，而对数据一致性的破坏主要来自两个方面：

- 事务的并发执行
- 事务故障或系统故障

数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。

并发控制技术保证了事务的隔离性，使数据库的一致性状态不会因为并发执行的操作被破坏。

日志恢复技术保证了事务的原子性，使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失，保证了事务的持久性。

本文将对以上两种技术进行详细介绍。

![1422237-20181122103102223-1059881337.png](https://i.loli.net/2019/11/05/kESoJcXzCF3eWmv.png)





## 事务的并发控制

### 并发控制简介

这里之所以要特别介绍事务的并发（Concurrency），是因为它是数据库系统中一个非常基本也非常重要的概念。虽然单个事务的执行可能没有任何错误，但是当多个事务同时并发执行时，不同事务中的操作可能交叉进行彼此干扰，就会造成数据库的一致性出现问题。而串行（完全隔离）执行虽然能够允许开发者忽略并行造成的影响，能够很好地维护数据库的一致性，但是却会影响事务执行的性能，极大降低吞吐量和资源利用率 。所以说数据库的并发性和隔离性其实是一个需要开发者去权衡的问题。

要对事务并发和隔离有个快速的理解，其实只需要看 [A Critique of ANSI SQL Isolation Levels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf) 这篇论文就足够了，其详细介绍了数据库事务并发可能存在的各种问题，根据对一致性的影响由强到弱（非绝对）大致列举如下：

- P0: 脏写（Dirty Write）
- P1: 脏读（Dirty Read）
- P2: 不可重复读（Non-repeatable Read/Fuzzy Read）
- P3: 幻读（Phantom Read）
- P4: 丢失更新（Lost Update）
- P4C: 游标丢失更新（Cursor Lost Update）
- A5A: 读偏（Read Skew）
- A5B: 写偏（Write Skew）

（P是Phenomena，即现象的缩写）

针对以上并发问题，论文引入了事务隔离的机制。在最开始的 SQL 标准中定义了四种数据库的事务的隔离（Isolation）级别，随着技术的演进，出现了很多当初的标准没有定义的新的隔离级别，诸如Snapshot Isoloation等。论文中详细阐述了6种隔离级别：

- 读未提交（Read Uncommitted）
- 读已提交（Read Committed）
- 游标稳定性（Cursor Stability）
- 可重复读（Repeatable Read）
- 快照隔离（Snapshot）
- 可串行化（Serializable）

以上每种隔离级别强度逐层递进，解决并发异常的能力由弱渐强，由此带来性能上的牺牲也依次增大。

总体来说，不同的隔离级别的选择，实质上是依据业务需求，对数据库在并发性能和数据一致性之间作出不同程度的折中，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性。

### 常见并发异常

- 

#### 脏写（Dirty Write）





### 事务隔离的目的

在多用户操作的数据库中，需要对于数据访问的并发性能和数据的一致性进行合理的控制。为了解决事务并发时的一致性问题，引入了事务隔离的机制，即多个线程同时操作数据库的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。当然，对一个单用户、单线程的应用来说则不存在这个问题。